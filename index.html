<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple Data Table</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #020617;
      --accent: #22c55e;
      --accent-soft: rgba(34, 197, 94, 0.14);
      --border: #1f2937;
      --text: #e5e7eb;
      --text-muted: #9ca3af;
      --header-bg: #020617;
      --cell-bg: #020617;
      --cell-hover: #111827;
      --danger: #ef4444;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #1f2937, #020617 55%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 24px;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      background: linear-gradient(
        145deg,
        rgba(15, 23, 42, 0.96),
        rgba(15, 23, 42, 0.98)
      );
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.75);
      padding: 20px 20px 24px;
      backdrop-filter: blur(18px);
    }

    @media (min-width: 768px) {
      .app {
        padding: 24px 28px 28px;
      }
    }

    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
      margin-bottom: 16px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
      padding-bottom: 12px;
    }

    .app-title {
      font-size: 1.25rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .badge {
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      color: var(--text-muted);
    }

    .app-subtitle {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 14px;
    }

    button {
      border-radius: 999px;
      padding: 7px 14px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: radial-gradient(
        circle at top left,
        rgba(34, 197, 94, 0.12),
        rgba(15, 23, 42, 0.95)
      );
      color: var(--text);
      font-size: 0.85rem;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      outline: none;
      transition: background 0.15s ease, border-color 0.15s ease,
        transform 0.06s ease, box-shadow 0.15s ease;
      box-shadow: 0 0 0 rgba(34, 197, 94, 0.0);
    }

    button span.icon {
      font-size: 1rem;
      line-height: 1;
    }

    button:hover {
      background: radial-gradient(
        circle at top left,
        rgba(34, 197, 94, 0.21),
        rgba(15, 23, 42, 0.98)
      );
      border-color: var(--accent);
      box-shadow: 0 0 18px rgba(34, 197, 94, 0.25);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 0 0 rgba(34, 197, 94, 0.0);
    }

    button.danger {
      background: radial-gradient(
        circle at top left,
        rgba(239, 68, 68, 0.12),
        rgba(15, 23, 42, 0.95)
      );
      border-color: rgba(239, 68, 68, 0.65);
      box-shadow: 0 0 0 rgba(239, 68, 68, 0.0);
    }

    button.danger:hover {
      background: radial-gradient(
        circle at top left,
        rgba(239, 68, 68, 0.22),
        rgba(15, 23, 42, 0.98)
      );
      border-color: var(--danger);
      box-shadow: 0 0 18px rgba(239, 68, 68, 0.35);
    }

    .table-scrollbar,
    .table-wrapper {
      border-radius: 14px;
      border: 1px solid rgba(51, 65, 85, 0.8);
      background: rgba(15, 23, 42, 0.95);
      scrollbar-width: thin;
      scrollbar-color: rgba(56, 189, 248, 0.7) rgba(30, 41, 59, 0.85);
      -webkit-overflow-scrolling: touch;
      touch-action: pan-x pan-y;
      overscroll-behavior-x: contain;
    }

    .table-wrapper {
      overflow-x: auto;
    }

    .table-scrollbar {
      overflow-x: auto;
      overflow-y: hidden;
      height: 12px;
      margin-bottom: 10px;
    }

    .table-scrollbar::-webkit-scrollbar,
    .table-wrapper::-webkit-scrollbar {
      height: 8px;
    }

    .table-scrollbar::-webkit-scrollbar-track,
    .table-wrapper::-webkit-scrollbar-track {
      background: rgba(30, 41, 59, 0.85);
      border-radius: 999px;
    }

    .table-scrollbar::-webkit-scrollbar-thumb,
    .table-wrapper::-webkit-scrollbar-thumb {
      background: linear-gradient(90deg, #38bdf8, #0ea5e9);
      border-radius: 999px;
      border: 1px solid rgba(14, 165, 233, 0.5);
    }

    .table-scrollbar-inner {
      height: 1px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 450px;
      table-layout: fixed;
    }

    @media (max-width: 640px) {
      body {
        padding: 12px;
        font-size: 0.95rem;
      }

      .app {
        padding: 14px;
      }

      .table-wrapper,
      .table-scrollbar {
        margin: 0 -6px;
      }

      table {
        min-width: 0;
      }

      /* Disable sticky columns on small screens */
      .sticky-col {
        position: static;
        left: auto !important;
        z-index: auto;
      }

      .app-header {
        margin-bottom: 12px;
        padding-bottom: 10px;
        gap: 8px;
      }

      .app-title {
        font-size: 1.1rem;
        gap: 6px;
      }

      .badge {
        padding: 2px 6px;
        font-size: 0.7rem;
      }

      .app-subtitle {
        font-size: 0.8rem;
      }

      .controls {
        gap: 6px;
        margin-bottom: 10px;
      }

      button {
        padding: 6px 12px;
        font-size: 0.82rem;
        gap: 5px;
      }

      th .header-inner {
        gap: 4px;
      }

      th,
      td {
        padding: 6px 5px;
        font-size: 0.8rem;
      }

      .cell {
        padding: 3px 4px;
        margin: -3px -4px;
        min-height: 16px;
      }

      .column-letter-pill {
        padding: 6px 8px;
        font-size: 0.8rem;
      }
    }

    thead {
      position: sticky;
      top: 0;
      z-index: 5;
      background: linear-gradient(
        to bottom,
        rgba(15, 23, 42, 1),
        rgba(15, 23, 42, 0.96)
      );
    }

    th,
    td {
      border-bottom: 1px solid rgba(30, 41, 59, 0.85);
      padding: 8px 10px;
      font-size: 0.85rem;
      text-align: left;
      vertical-align: middle;
    }

    th:not(:last-child),
    td:not(:last-child) {
      border-right: 1px solid rgba(30, 41, 59, 0.6);
    }

    th {
      font-weight: 500;
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      position: relative;
      user-select: none;
      cursor: pointer;
      white-space: nowrap;
    }

    .column-resizer {
      position: absolute;
      top: 0;
      right: -3px;
      width: 8px;
      height: 100%;
      cursor: col-resize;
      user-select: none;
      touch-action: none;
      opacity: 0;
      transition: opacity 0.12s ease;
    }

    th:hover .column-resizer,
    th:focus-within .column-resizer,
    .column-resizer.active {
      opacity: 1;
    }

    th.resizing-hover {
      cursor: col-resize;
    }

    th.resizing-hover .column-resizer {
      opacity: 1;
    }

    body.resizing-column,
    body.resizing-column * {
      cursor: col-resize !important;
      user-select: none !important;
    }

    th .header-inner {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    th .drag-handle {
      opacity: 0.4;
      font-size: 0.85rem;
      cursor: grab;
    }

    .locked-column .drag-handle {
      display: none;
    }

    th.drag-over {
      outline: 1px dashed rgba(34, 197, 94, 0.55);
      outline-offset: 4px;
    }

    th .header-label {
      pointer-events: none;
    }

    th .sort-indicator {
      display: none;
      font-size: 0.7rem;
      color: var(--text-muted);
      opacity: 0.4;
      min-width: 10px;
      text-align: center;
    }

    th.sorted-asc,
    th.sorted-desc {
      color: var(--accent);
    }

    th.sorted-asc .sort-indicator,
    th.sorted-desc .sort-indicator {
      opacity: 1;
      color: var(--accent);
    }

    tbody tr:nth-child(even) {
      background: rgba(15, 23, 42, 0.96);
    }

    tbody tr:nth-child(odd) {
      background: rgba(15, 23, 42, 0.99);
    }

    tbody tr:hover {
      background: var(--cell-hover);
    }

    td {
      color: var(--text);
    }

    .cell {
      min-width: 80px;
      outline: none;
      border-radius: 6px;
      padding: 4px 6px;
      margin: -4px -6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-height: 18px;
      cursor: text;
      width: 100%;
      text-align: center;
    }

    .numeric-cell {
      text-align: center;
      justify-content: center;
    }

    .high-number {
      color: #ff4d4d;
      font-weight: 700;
    }

    .cell:focus {
      background: rgba(15, 23, 42, 0.9);
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.8);
    }

    .name-cell {
      color: #38bdf8;
      font-weight: 600;
    }

    .formula-cell {
      color: var(--accent);
      background: rgba(34, 197, 94, 0.08);
      border: 1px dashed rgba(34, 197, 94, 0.4);
      border-radius: 6px;
      padding: 4px 6px;
      margin: -4px -6px;
      cursor: default;
    }

    .suggestion-dropdown {
      position: absolute;
      background: var(--panel);
      border: 1px solid rgba(148, 163, 184, 0.4);
      border-radius: 10px;
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.45);
      padding: 6px 0;
      z-index: 20;
      min-width: 140px;
      overflow: hidden;
    }

    .suggestion-dropdown.hidden {
      display: none;
    }

    .suggestion-item {
      padding: 7px 14px;
      cursor: pointer;
      color: var(--text);
      white-space: nowrap;
      font-size: 0.85rem;
      transition: background 0.12s ease, color 0.12s ease;
    }

    .suggestion-item:hover {
      background: var(--cell-hover);
      color: var(--accent);
    }

    .icon-cell {
      width: 44px;
      text-align: center;
      padding-right: 6px;
    }

    .sticky-col {
      position: sticky;
      left: var(--sticky-left, 0);
      background: rgba(15, 23, 42, 0.99);
    }

    thead .sticky-col {
      z-index: 7;
    }

    .column-letter-row .sticky-col {
      z-index: 8;
    }

    tbody .sticky-col {
      z-index: 3;
    }

    .image-link {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 8px;
      background: rgba(56, 189, 248, 0.12);
      border: 1px solid rgba(56, 189, 248, 0.35);
      color: #e5e7eb;
      text-decoration: none;
      transition: background 0.15s ease, transform 0.08s ease,
        border-color 0.15s ease, box-shadow 0.15s ease;
      font-size: 0.95rem;
    }

    .image-link:hover {
      background: rgba(56, 189, 248, 0.2);
      border-color: #38bdf8;
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.35);
      transform: translateY(-1px);
    }

    .image-link:active {
      transform: translateY(0);
    }

    .image-link.disabled,
    .image-link.disabled:hover {
      border-color: rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.12);
      box-shadow: none;
      transform: none;
      cursor: not-allowed;
    }

    .hint-bar {
      margin-top: 8px;
      font-size: 0.78rem;
      color: var(--text-muted);
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .hint-pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px dashed rgba(148, 163, 184, 0.4);
    }

    .column-letter-row th {
      border-bottom: 1px solid rgba(30, 41, 59, 0.85);
      padding: 0;
      text-align: left;
    }

    .column-letter {
      padding: 0;
    }

    .column-letter-pill {
      display: block;
      width: 100%;
      padding: 8px 10px;
      border-radius: 6px;
      background: rgba(148, 163, 184, 0.12);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text);
      font-weight: 700;
      font-size: 0.75rem;
      letter-spacing: 0.04em;
      min-width: 28px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="app-header">
      <div>
        <div class="app-title">
          Simple Data Table
          <span class="badge">Netlify-ready</span>
        </div>
        <div class="app-subtitle">
          Click cells to edit ‚Ä¢ Click headers to sort ‚Ä¢ Double-click headers to rename
          or set formulas. Drag headers to rearrange columns.
        </div>
      </div>
    </div>

    <div class="controls">
      <button id="addRowBtn">
        <span class="icon">‚ûï</span>
        Add Row
      </button>
      <button id="addColBtn">
        <span class="icon">üìä</span>
        Add Column
      </button>
      <button id="deleteRowBtn" class="danger">
        <span class="icon">‚ûñ</span>
        Delete Row
      </button>
      <button id="deleteColBtn" class="danger">
        <span class="icon">üßπ</span>
        Delete Column
      </button>
      <button id="exportBtn">
        <span class="icon">‚¨áÔ∏è</span>
        Export Data
      </button>
      <button id="importBtn">
        <span class="icon">‚¨ÜÔ∏è</span>
        Import Data
      </button>
      <button id="clearBtn" class="danger">
        <span class="icon">üóëÔ∏è</span>
        Clear All Data
      </button>
      <input
        type="file"
        id="importFileInput"
        accept="application/json,.json,.xlsx,.xls,.csv"
        hidden
      />
    </div>

    <div class="table-scrollbar" id="tableScrollTop">
      <div class="table-scrollbar-inner" id="tableScrollTopInner"></div>
    </div>

    <div class="table-wrapper" id="tableWrapper">
      <table id="dataTable">
        <thead>
          <tr class="column-letter-row">
            <th data-col-index="0" class="column-letter">
              <span class="column-letter-pill">A</span>
            </th>
            <th data-col-index="1" class="column-letter">
              <span class="column-letter-pill">B</span>
            </th>
            <th data-col-index="2" class="column-letter">
              <span class="column-letter-pill">C</span>
            </th>
          </tr>
          <tr class="header-row">
            <th data-col-index="0" class="icon-cell">
              <span class="header-inner">
                <span class="header-label">Images</span>
                <span class="sort-indicator">‚áÖ</span>
              </span>
            </th>
            <th data-col-index="1">
              <span class="header-inner">
                <span class="header-label">Name</span>
                <span class="sort-indicator">‚áÖ</span>
              </span>
            </th>
            <th data-col-index="2">
              <span class="header-inner">
                <span class="header-label">Rating</span>
                <span class="sort-indicator">‚áÖ</span>
              </span>
            </th>
          </tr>
        </thead>
        <tbody>
          <!-- rows will be created by JS -->
        </tbody>
      </table>
    </div>

    <div class="hint-bar">
      <span class="hint-pill">
        üîç Anything typed in the <strong>Name</strong> column becomes a Google Images link.
      </span>
      <span>
        Use the new image icon in each row to open Google Images for that name.
      </span>
      <span class="hint-pill">
        üßÆ Double-click a column header to add a formula. Use column letters like
        <strong>=AVERAGE(D:H)</strong>.
      </span>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    const table = document.getElementById("dataTable");
    const tableWrapper = document.getElementById("tableWrapper");
    const topScrollbar = document.getElementById("tableScrollTop");
    const topScrollbarInner = document.getElementById("tableScrollTopInner");
    const thead = table.querySelector("thead");
    const headerRow = thead.querySelector(".header-row");
    const letterRow = thead.querySelector(".column-letter-row");
    const tbody = table.querySelector("tbody");

    const STORAGE_KEY = "simple-data-table-state";

    const storage = (() => {
      try {
        const testKey = "__storage_test__";
        localStorage.setItem(testKey, "ok");
        localStorage.removeItem(testKey);

        return {
          getItem: (key) => localStorage.getItem(key),
          setItem: (key, value) => localStorage.setItem(key, value),
          removeItem: (key) => localStorage.removeItem(key),
          available: true,
        };
      } catch (err) {
        console.warn("Local storage unavailable, using in-memory fallback.", err);
        const memoryStore = {};

        return {
          getItem: (key) => memoryStore[key] || null,
          setItem: (key, value) => {
            memoryStore[key] = value;
          },
          removeItem: (key) => {
            delete memoryStore[key];
          },
          available: false,
        };
      }
    })();

    const addRowBtn = document.getElementById("addRowBtn");
    const addColBtn = document.getElementById("addColBtn");
    const deleteRowBtn = document.getElementById("deleteRowBtn");
    const deleteColBtn = document.getElementById("deleteColBtn");
    const exportBtn = document.getElementById("exportBtn");
    const importBtn = document.getElementById("importBtn");
    const clearBtn = document.getElementById("clearBtn");
    const importFileInput = document.getElementById("importFileInput");

    const COLUMN_TYPES = {
      ICON: "icon",
      NAME: "name",
      TEXT: "text",
    };

    const getHeaderCells = () => Array.from(headerRow.querySelectorAll("th"));
    const getLetterCells = () => Array.from(letterRow.querySelectorAll("th"));

    const AGE_LABEL = "age";
    const NAME_LABEL = "name";

    const LOCAL_BIRTHDAY_DB = {
      "ada lovelace": { birth: "1815-12-10", death: "1852-11-27" },
      "alan turing": { birth: "1912-06-23", death: "1954-06-07" },
      "grace hopper": { birth: "1906-12-09", death: "1992-01-01" },
      "katherine johnson": { birth: "1918-08-26", death: "2020-02-24" },
      "elon musk": { birth: "1971-06-28", death: null },
    };

    const birthdayCache = new Map();

    function ensureLetterCells(count) {
      while (letterRow.children.length < count) {
        const index = letterRow.children.length;
        const letterCell = document.createElement("th");
        letterCell.className = "column-letter";
        letterCell.dataset.colIndex = index;
        const pill = document.createElement("span");
        pill.className = "column-letter-pill";
        pill.textContent = indexToColumnLabel(index);
        letterCell.appendChild(pill);
        letterRow.appendChild(letterCell);
      }

      while (letterRow.children.length > count) {
        letterRow.removeChild(letterRow.lastChild);
      }
    }

    const DEFAULT_ROW_COUNT = 10;
    const DEFAULT_HEADERS = [
      { label: "Images", type: COLUMN_TYPES.ICON },
      { label: "Name", type: COLUMN_TYPES.NAME },
      { label: "Rating", type: COLUMN_TYPES.TEXT },
    ];

    const MIN_COLUMN_WIDTH = 70;
    const MIN_ICON_WIDTH = 50;
    const LOCKED_COLUMN_COUNT = 2;

    // Track sort direction per column: "asc" or "desc"
    const sortState = {};
    let isDraggingColumn = false;
    let dragSourceIndex = null;

    const NUMERIC_VALUE_PATTERN = /^-?\d+(?:\.\d+)?$/;
    const columnSuggestions = new Map();
    let activeSuggestionCell = null;

    const suggestionDropdown = document.createElement("div");
    suggestionDropdown.className = "suggestion-dropdown hidden";
    document.body.appendChild(suggestionDropdown);

    document.addEventListener("focusin", (event) => {
      if (!activeSuggestionCell) return;
      const targetCell = event.target.closest?.(".cell, .name-cell");
      if (targetCell === activeSuggestionCell) return;
      if (suggestionDropdown.contains(event.target)) return;
      hideSuggestionDropdown();
    });

    document.addEventListener("mousedown", (event) => {
      if (!activeSuggestionCell) return;
      if (suggestionDropdown.contains(event.target)) return;
      const targetCell = event.target.closest?.(".cell, .name-cell");
      if (targetCell === activeSuggestionCell) return;
      hideSuggestionDropdown();
    });

    let isSyncingScroll = false;
    let pendingScrollFrame = null;
    let pendingScrollLeft = null;

    function refreshScrollbars() {
      if (!table || !topScrollbarInner || !tableWrapper) return;

      requestAnimationFrame(() => {
        topScrollbarInner.style.width = `${table.scrollWidth}px`;
        if (topScrollbar) {
          topScrollbar.scrollLeft = tableWrapper.scrollLeft;
        }
      });
    }

    function mirrorScrollPosition(source, target) {
      if (!target || isSyncingScroll) return;
      pendingScrollLeft = source.scrollLeft;

      if (pendingScrollFrame) {
        return;
      }

      pendingScrollFrame = requestAnimationFrame(() => {
        isSyncingScroll = true;
        target.scrollLeft = pendingScrollLeft;
        isSyncingScroll = false;
        pendingScrollFrame = null;
        pendingScrollLeft = null;
      });
    }

    if (tableWrapper && topScrollbar) {
      tableWrapper.addEventListener(
        "scroll",
        () => mirrorScrollPosition(tableWrapper, topScrollbar),
        { passive: true }
      );

      topScrollbar.addEventListener(
        "scroll",
        () => mirrorScrollPosition(topScrollbar, tableWrapper),
        { passive: true }
      );
    }

    window.addEventListener("resize", refreshScrollbars);

    function columnLabelToIndex(label) {
      if (!/^[A-Za-z]+$/.test(label)) return null;
      const upper = label.toUpperCase();
      let index = 0;
      for (let i = 0; i < upper.length; i++) {
        index = index * 26 + (upper.charCodeAt(i) - 64);
      }
      return index - 1;
    }

    function indexToColumnLabel(index) {
      let n = index + 1;
      let label = "";
      while (n > 0) {
        const remainder = (n - 1) % 26;
        label = String.fromCharCode(65 + remainder) + label;
        n = Math.floor((n - 1) / 26);
      }
      return label;
    }

    function normalizeHeaderLabel(label) {
      return (label || "").trim().toLowerCase();
    }

    function escapeRegExp(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function getColumnLabelLookup(columns = getColumnDefinitions()) {
      const lookup = new Map();
      columns.forEach((col, idx) => {
        const normalized = normalizeHeaderLabel(col.label);
        if (normalized && !lookup.has(normalized)) {
          lookup.set(normalized, { index: idx, label: col.label });
        }
      });
      return lookup;
    }

    function getColumnIndexByLabel(lookup, rawLabel) {
      const normalized = normalizeHeaderLabel(rawLabel);
      const entry = lookup.get(normalized);
      if (entry) return entry.index;
      const fallback = columnLabelToIndex(rawLabel);
      return fallback;
    }

    function buildColumnLabelPattern(lookup) {
      const labels = Array.from(lookup.values())
        .map(({ label }) => escapeRegExp(label || ""))
        .filter(Boolean);
      if (!labels.length) return null;
      return new RegExp(`\\b(${labels.join("|")})\\b`, "gi");
    }

    function buildImageSearchUrl(query) {
      return "https://www.google.com/search?tbm=isch&q=" +
        encodeURIComponent(query);
    }

    function createCell(columnType, { formula } = {}) {
      const td = document.createElement("td");

      if (columnType === COLUMN_TYPES.ICON) {
        td.className = "icon-cell";

        const link = document.createElement("a");
        link.href = "#";
        link.target = "_blank";
        link.className = "image-link disabled";
        link.title = "Open Google Images for this name";

        link.addEventListener("click", (e) => {
          if (link.classList.contains("disabled")) {
            e.preventDefault();
          }
        });

        link.textContent = "üñºÔ∏è";
        td.appendChild(link);
      } else if (columnType === COLUMN_TYPES.NAME) {
        // Name column: editable text
        const div = document.createElement("div");
        div.className = "cell name-cell";
        if (!formula) {
          div.setAttribute("contenteditable", "true");
          div.addEventListener("keydown", handleCellKeyDown);
          attachSuggestionEvents(div);
        } else {
          div.classList.add("formula-cell");
        }
        div.dataset.role = "name";

        // Update icon link whenever text changes
        if (!formula) {
          div.addEventListener("input", handleNameInput);
          div.addEventListener("input", handleCellChange);
        }

        td.appendChild(div);
      } else {
        // Regular editable text cell
        const div = document.createElement("div");
        div.className = "cell";
        if (!formula) {
          div.setAttribute("contenteditable", "true");
          div.addEventListener("input", handleCellChange);
          div.addEventListener("keydown", handleCellKeyDown);
          attachSuggestionEvents(div);
        } else {
          div.classList.add("formula-cell");
        }
        td.appendChild(div);
      }

      return td;
    }

    function normalizePersonName(name) {
      return name?.trim().toLowerCase() || "";
    }

    function computeAgeFromDates(birthDateString, referenceDateString) {
      const birth = new Date(birthDateString);
      const reference = referenceDateString
        ? new Date(referenceDateString)
        : new Date();

      if (Number.isNaN(birth.getTime()) || Number.isNaN(reference.getTime())) {
        return null;
      }

      let age = reference.getFullYear() - birth.getFullYear();
      const hasNotHadBirthdayYet =
        reference.getMonth() < birth.getMonth() ||
        (reference.getMonth() === birth.getMonth() &&
          reference.getDate() < birth.getDate());

      if (hasNotHadBirthdayYet) {
        age -= 1;
      }

      return age >= 0 ? age : null;
    }

    function extractWikidataDate(claim) {
      const timeValue = claim?.mainsnak?.datavalue?.value?.time;
      if (!timeValue || typeof timeValue !== "string") return null;

      // Wikidata times can include a leading + and time portion; strip them.
      const normalized = timeValue.replace(/^\+/, "").split("T")[0];
      return normalized;
    }

    async function fetchBirthdayFromWikidata(name) {
      const searchParams = new URLSearchParams({
        action: "query",
        list: "search",
        srsearch: name,
        format: "json",
        origin: "*",
      });

      const searchUrl =
        "https://api.wikidata.org/w/api.php?" + searchParams.toString();

      const searchResponse = await fetch(searchUrl);
      if (!searchResponse.ok) return null;
      const searchJson = await searchResponse.json();
      const topResult = searchJson?.query?.search?.[0];
      const title = topResult?.title;
      if (!title) return null;

      const entityUrl =
        "https://www.wikidata.org/wiki/Special:EntityData/" + title + ".json";

      const entityResponse = await fetch(entityUrl);
      if (!entityResponse.ok) return null;
      const entityJson = await entityResponse.json();
      const entity = entityJson?.entities?.[title];
      if (!entity) return null;

      const birthClaim = entity?.claims?.P569?.[0];
      if (!birthClaim) return null;

      const instanceClaims = entity?.claims?.P31 || [];
      const isHuman =
        instanceClaims.length === 0 ||
        instanceClaims.some((claim) => {
          const id = claim?.mainsnak?.datavalue?.value?.id;
          return typeof id === "string" && id.toUpperCase() === "Q5";
        });

      if (!isHuman) return null;

      const deathClaim = entity?.claims?.P570?.[0];

      const birth = extractWikidataDate(birthClaim);
      const death = extractWikidataDate(deathClaim);

      if (!birth) return null;

      return { birth, death: death || null };
    }

    async function resolvePersonDates(rawName) {
      const normalized = normalizePersonName(rawName);
      if (!normalized) return null;

      if (birthdayCache.has(normalized)) {
        return await Promise.resolve(birthdayCache.get(normalized));
      }

      const localRecord = LOCAL_BIRTHDAY_DB[normalized];
      if (localRecord) {
        birthdayCache.set(normalized, localRecord);
        return localRecord;
      }

      const fetchPromise = (async () => {
        try {
          return await fetchBirthdayFromWikidata(rawName);
        } catch (err) {
          console.warn("Failed to fetch birth data for", rawName, err);
          return null;
        }
      })();

      birthdayCache.set(normalized, fetchPromise);
      return fetchPromise;
    }

    function placeCursorAtEnd(element) {
      const range = document.createRange();
      range.selectNodeContents(element);
      range.collapse(false);

      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    }

    function moveFocusByOffset(currentCell, { rowOffset = 0, colOffset = 0 }) {
      const currentTd = currentCell.closest("td");
      const currentRow = currentTd?.parentElement;
      if (!currentTd || !currentRow) return;

      const rows = Array.from(tbody.querySelectorAll("tr"));
      const currentRowIndex = rows.indexOf(currentRow);
      const currentColIndex = Array.from(currentRow.children).indexOf(currentTd);

      if (currentColIndex < 0 || currentRowIndex < 0) return;

      let targetRowIndex = currentRowIndex + rowOffset;
      const targetColIndex = currentColIndex + colOffset;

      if (targetColIndex < 0 || targetColIndex >= getHeaderCells().length) return;

      if (targetRowIndex < 0) targetRowIndex = 0;

      if (targetRowIndex >= rows.length) {
        addRow();
        targetRowIndex = tbody.querySelectorAll("tr").length - 1;
      }

      const targetRow = tbody.querySelectorAll("tr")[targetRowIndex];
      const nextCell = targetRow?.children?.[targetColIndex]?.querySelector(
        ".cell, .name-cell"
      );

      if (nextCell) {
        nextCell.focus();
        placeCursorAtEnd(nextCell);
      }
    }

    function handleCellKeyDown(event) {
      const cell = event.currentTarget;
      const selection = window.getSelection();
      const isInCell = selection && cell.contains(selection.anchorNode);
      const isCollapsed = Boolean(selection?.isCollapsed);
      const caretOffset = isInCell && isCollapsed ? selection.anchorOffset : null;
      const cellLength = cell.textContent?.length || 0;
      const atStart = caretOffset === 0;
      const atEnd = caretOffset === cellLength;

      if (event.key === "Enter") {
        event.preventDefault();
        moveFocusByOffset(cell, { rowOffset: 1, colOffset: 0 });
      }

      if (event.key === "ArrowDown") {
        event.preventDefault();
        moveFocusByOffset(cell, { rowOffset: 1, colOffset: 0 });
      }

      if (event.key === "ArrowUp") {
        event.preventDefault();
        moveFocusByOffset(cell, { rowOffset: -1, colOffset: 0 });
      }

      if (event.key === "ArrowLeft" && (atStart || cellLength === 0)) {
        event.preventDefault();
        moveFocusByOffset(cell, { rowOffset: 0, colOffset: -1 });
      }

      if (event.key === "ArrowRight" && (atEnd || cellLength === 0)) {
        event.preventDefault();
        moveFocusByOffset(cell, { rowOffset: 0, colOffset: 1 });
      }
    }

    function handleNameInput(event) {
      const nameCell = event.target;
      const text = nameCell.textContent.trim();
      const row = nameCell.closest("tr");
      const imageLink = row?.querySelector(".image-link");

      if (!imageLink) return;

      if (text) {
        imageLink.href = buildImageSearchUrl(text);
        imageLink.classList.remove("disabled");
        imageLink.setAttribute(
          "aria-label",
          `Open Google Images for ${text}`
        );
      } else {
        imageLink.href = "#";
        imageLink.classList.add("disabled");
        imageLink.setAttribute(
          "aria-label",
          "Google Images (enter a name first)"
        );
      }
    }

    function handleCellChange(event) {
      let colIndex = null;
      let row = null;

      if (event?.target) {
        const cell = event.target;
        const td = cell.closest("td");
        colIndex = td?.cellIndex;
        row = td?.parentElement || null;
        const header = Number.isInteger(colIndex)
          ? getHeaderCells()[colIndex]
          : null;

        if (header?.dataset.type !== COLUMN_TYPES.ICON) {
          rememberColumnSuggestion(colIndex, cell.textContent || "");
        }
      }

      const columns = getColumnDefinitions();
      const ageColumnIndices = getAgeColumnIndices(columns);
      const hasAgeColumns = ageColumnIndices.length > 0;
      const nameColumnIndex = findColumnIndexByLabel(columns, NAME_LABEL);
      const isNameEdit =
        hasAgeColumns &&
        Number.isInteger(colIndex) &&
        colIndex === nameColumnIndex;

      recalculateFormulas({ skipAgeUpdate: hasAgeColumns });

      if (hasAgeColumns) {
        if (isNameEdit && row) {
          const existingTimer = ageUpdateDebounceTimers.get(row);
          if (existingTimer) {
            clearTimeout(existingTimer);
          }

          const timeoutId = window.setTimeout(() => {
            ageUpdateDebounceTimers.delete(row);
            updateAgeColumns(columns);
          }, 500);

          ageUpdateDebounceTimers.set(row, timeoutId);
        } else {
          updateAgeColumns(columns);
        }
      }

      saveTableState();
    }

    function shouldStoreSuggestion(value) {
      const trimmed = value.trim();
      if (!trimmed) return false;
      if (NUMERIC_VALUE_PATTERN.test(trimmed)) return false;
      return /[a-zA-Z]/.test(trimmed) || trimmed.includes(" ");
    }

    function rememberColumnSuggestion(colIndex, value) {
      if (!Number.isInteger(colIndex) || !shouldStoreSuggestion(value)) return;
      if (!columnSuggestions.has(colIndex)) {
        columnSuggestions.set(colIndex, new Set());
      }

      columnSuggestions.get(colIndex).add(value.trim());
    }

    function rebuildColumnSuggestionsFromTable() {
      columnSuggestions.clear();
      const headers = getColumnDefinitions();
      Array.from(tbody.querySelectorAll("tr")).forEach((row) => {
        headers.forEach((col, idx) => {
          if (col.type === COLUMN_TYPES.ICON) return;
          const cell = row.children[idx]?.querySelector(".cell, .name-cell");
          if (!cell) return;
          rememberColumnSuggestion(idx, cell.textContent || "");
        });
      });
    }

    function getSuggestionsForColumn(colIndex, currentValue = "") {
      const suggestions = columnSuggestions.get(colIndex);
      if (!suggestions) return [];
      const normalizedCurrent = currentValue.trim();
      return Array.from(suggestions).filter((entry) => entry !== normalizedCurrent);
    }

    function hideSuggestionDropdown() {
      suggestionDropdown.classList.add("hidden");
      suggestionDropdown.innerHTML = "";
      activeSuggestionCell = null;
    }

    function positionSuggestionDropdown(cell) {
      const rect = cell.getBoundingClientRect();
      suggestionDropdown.style.minWidth = `${rect.width}px`;
      suggestionDropdown.style.left = `${window.scrollX + rect.left}px`;
      suggestionDropdown.style.top = `${window.scrollY + rect.bottom + 6}px`;
    }

    function applySuggestion(cell, value) {
      cell.textContent = value;
      placeCursorAtEnd(cell);
      cell.focus();
      handleCellChange({ target: cell });
      hideSuggestionDropdown();
    }

    function showSuggestionsForCell(cell) {
      const td = cell.closest("td");
      const colIndex = td?.cellIndex;
      if (!Number.isInteger(colIndex)) return;

      const options = getSuggestionsForColumn(colIndex, cell.textContent || "");
      if (!options.length) {
        hideSuggestionDropdown();
        return;
      }

      suggestionDropdown.innerHTML = "";

      options.forEach((option) => {
        const item = document.createElement("div");
        item.className = "suggestion-item";
        item.textContent = option;
        item.addEventListener("mousedown", (e) => {
          e.preventDefault();
          applySuggestion(cell, option);
        });
        suggestionDropdown.appendChild(item);
      });

      activeSuggestionCell = cell;
      positionSuggestionDropdown(cell);
      suggestionDropdown.classList.remove("hidden");
    }

    function attachSuggestionEvents(cell) {
      if (cell.dataset.suggestionAttached === "true") return;

      cell.addEventListener("focus", () => showSuggestionsForCell(cell));
      cell.addEventListener("input", () => {
        if (activeSuggestionCell === cell) {
          showSuggestionsForCell(cell);
        }
      });

      cell.dataset.suggestionAttached = "true";
    }

    function applyNumericStyling(cell) {
      if (!cell) return;
      const raw = cell.textContent || "";
      const numericValue = Number(raw.trim());
      const isNumeric = raw.trim() !== "" && Number.isFinite(numericValue);
      const isHighNumber = isNumeric && numericValue >= 90;

      cell.classList.toggle("numeric-cell", isNumeric);
      cell.classList.toggle("high-number", isHighNumber);
    }

    function refreshNumericStyling() {
      Array.from(tbody.querySelectorAll(".cell, .name-cell")).forEach(
        applyNumericStyling
      );
    }

    function addRow() {
      const columnDefinitions = getColumnDefinitions();
      const tr = document.createElement("tr");

      columnDefinitions.forEach((col) => {
        tr.appendChild(createCell(col.type, { formula: col.formula }));
      });

      tbody.appendChild(tr);
      applyColumnWidthsToRow(tr);
      applyStickyColumns();
      syncFormulaColumnCells();
      recalculateFormulas();
      saveTableState();

      return tr;
    }

    function parseIndexList(input, { max }) {
      const parts = input
        .split(/[\s,]+/)
        .map((part) => part.trim())
        .filter(Boolean);

      const indices = parts
        .map((part) => Number.parseInt(part, 10))
        .filter((num) => Number.isFinite(num) && num >= 1 && num <= max);

      return Array.from(new Set(indices));
    }

    function deleteRow() {
      const rows = Array.from(tbody.querySelectorAll("tr"));
      if (!rows.length) {
        alert("There are no rows to delete.");
        return;
      }

      const input = prompt(
        `Enter row numbers to delete (1-${rows.length}), separated by commas:`,
        String(rows.length)
      );

      if (input === null || input.trim() === "") return;

      const indicesToDelete = parseIndexList(input, { max: rows.length });

      if (!indicesToDelete.length) {
        alert("No valid row numbers were provided.");
        return;
      }

      indicesToDelete
        .sort((a, b) => b - a)
        .forEach((rowNumber) => {
          rows[rowNumber - 1]?.remove();
        });

      saveTableState();
    }

    function applyColumnWidthsToRow(tr) {
      const headers = getHeaderCells();
      headers.forEach((th, idx) => {
        const width = getColumnWidth(th);
        if (Number.isFinite(width)) {
          const cell = tr.children[idx];
          if (cell) {
            cell.style.width = `${width}px`;
          }
        }
      });
    }

    function addColumn() {
      const currentCols = getHeaderCells().length;
      const newIndex = currentCols;
      const defaultName = "Column " + (newIndex + 1);
      const headerName =
        prompt("New column name:", defaultName) || defaultName;

      // Create header cell
      const th = buildHeader(headerName, newIndex, COLUMN_TYPES.TEXT);
      headerRow.appendChild(th);
      ensureLetterCells(headerRow.children.length);
      refreshColumnIndices();

      // Add cells for each existing row
      Array.from(tbody.querySelectorAll("tr")).forEach((row) => {
        row.appendChild(createCell(COLUMN_TYPES.TEXT));
      });

      setColumnWidth(newIndex, 140);
      refreshScrollbars();

      recalculateFormulas();
      saveTableState();
    }

    function parseColumnSelection(input, max) {
      const parts = input
        .split(/[\s,]+/)
        .map((part) => part.trim())
        .filter(Boolean);

      const indices = parts
        .map((part) => {
          const letterIndex = columnLabelToIndex(part);
          if (letterIndex !== null) return letterIndex;

          const numeric = Number.parseInt(part, 10);
          if (Number.isFinite(numeric)) return numeric - 1;

          return null;
        })
        .filter((idx) => Number.isInteger(idx) && idx >= 0)
        .filter((idx) => idx < max);

      return Array.from(new Set(indices));
    }

    function deleteColumn() {
      const headers = getHeaderCells();
      if (headers.length <= 1) {
        alert("At least one column must remain in the table.");
        return;
      }

      const availableLabels = headers
        .map((_, idx) => indexToColumnLabel(idx))
        .join(", ");

      const input = prompt(
        `Enter column letters or numbers to delete (e.g., B or 2). Separate multiple with commas. Available: ${availableLabels}`,
        indexToColumnLabel(headers.length - 1)
      );

      if (input === null || input.trim() === "") return;

      const indicesToDelete = parseColumnSelection(input, headers.length);

      if (!indicesToDelete.length) {
        alert("No valid column identifiers were provided.");
        return;
      }

      if (headers.length - indicesToDelete.length < 1) {
        alert("At least one column must remain in the table.");
        return;
      }

      indicesToDelete
        .sort((a, b) => b - a)
        .forEach((colIndex) => {
          headers[colIndex]?.remove();
          getLetterCells()[colIndex]?.remove();

          Array.from(tbody.querySelectorAll("tr")).forEach((row) => {
            row.children[colIndex]?.remove();
          });
        });

      refreshColumnIndices();
      resetSortState();
      syncColumnLetterWidths();
      syncFormulaColumnCells();
      refreshScrollbars();
      recalculateFormulas();
      saveTableState();
    }

    function getHeaderIndex(th) {
      return getHeaderCells().indexOf(th);
    }

    const columnResizeState = {
      active: false,
      startX: 0,
      startWidth: 0,
      colIndex: null,
    };

    function getColumnWidth(th) {
      const datasetWidth = parseFloat(th.dataset.width);
      if (Number.isFinite(datasetWidth)) return datasetWidth;

      const styleWidth = parseFloat(th.style.width);
      if (Number.isFinite(styleWidth)) return styleWidth;

      const measuredWidth = Math.round(th.getBoundingClientRect().width);
      if (Number.isFinite(measuredWidth) && measuredWidth > 0) {
        return measuredWidth;
      }

      return null;
    }

    function syncColumnLetterWidths() {
      const headers = getHeaderCells();
      const letters = getLetterCells();

      headers.forEach((th, idx) => {
        const width = getColumnWidth(th);
        const letter = letters[idx];

        if (letter && Number.isFinite(width)) {
          letter.style.width = `${width}px`;
        }
      });
    }

    function applyWidthToCells(colIndex, width) {
      const pxWidth = `${width}px`;
      const header = getHeaderCells()[colIndex];
      const letterHeader = getLetterCells()[colIndex];
      if (header) {
        header.style.width = pxWidth;
        header.dataset.width = width;
      }

      if (letterHeader) {
        letterHeader.style.width = pxWidth;
      }

      Array.from(tbody.querySelectorAll("tr")).forEach((row) => {
        const cell = row.children[colIndex];
        if (cell) {
          cell.style.width = pxWidth;
        }
      });

      syncColumnLetterWidths();
      applyStickyColumns();
    }

    function setColumnWidth(colIndex, rawWidth) {
      const headers = getHeaderCells();
      const header = headers[colIndex];
      if (!header) return;

      const minWidth =
        header.dataset.type === COLUMN_TYPES.ICON ? MIN_ICON_WIDTH : MIN_COLUMN_WIDTH;
      const width = Math.max(minWidth, rawWidth);
      applyWidthToCells(colIndex, width);
      refreshScrollbars();
    }

    function applySavedColumnWidths() {
      const headers = getHeaderCells();
      headers.forEach((th, idx) => {
        const width = getColumnWidth(th);
        if (Number.isFinite(width)) {
          applyWidthToCells(idx, width);
        }
      });
    }

    function isLockedColumnIndex(index) {
      return Number.isInteger(index) && index < LOCKED_COLUMN_COUNT;
    }

    function applyStickyColumns() {
      const headers = getHeaderCells();
      const letters = getLetterCells();
      const rows = Array.from(tbody.querySelectorAll("tr"));

      let offset = 0;

      headers.forEach((th, idx) => {
        const isLocked = isLockedColumnIndex(idx);
        const rawWidth = getColumnWidth(th);
        const fallbackWidth =
          th.dataset.type === COLUMN_TYPES.ICON ? MIN_ICON_WIDTH : MIN_COLUMN_WIDTH;
        const width = rawWidth || fallbackWidth;
        const leftValue = isLocked ? offset : null;

        [th, letters[idx]].forEach((cell) => {
          if (!cell) return;
          cell.classList.toggle("sticky-col", isLocked);
          cell.classList.toggle("locked-column", isLocked);
          if (isLocked && leftValue !== null) {
            cell.style.setProperty("--sticky-left", `${leftValue}px`);
          } else {
            cell.style.removeProperty("--sticky-left");
          }
        });

        rows.forEach((row) => {
          const td = row.children[idx];
          if (!td) return;
          td.classList.toggle("sticky-col", isLocked);
          if (isLocked && leftValue !== null) {
            td.style.setProperty("--sticky-left", `${leftValue}px`);
          } else {
            td.style.removeProperty("--sticky-left");
          }
        });

        if (isLocked) {
          offset += width;
        }
      });
    }

    function startColumnResize(th, event) {
      const colIndex = getHeaderIndex(th);
      columnResizeState.active = true;
      columnResizeState.startX = event.clientX;
      columnResizeState.startWidth = th.getBoundingClientRect().width;
      columnResizeState.colIndex = colIndex;
      document.body.classList.add("resizing-column");

      const resizer = th.querySelector(".column-resizer");
      if (resizer) {
        resizer.classList.add("active");
      }

      document.addEventListener("mousemove", handleColumnResizeMove);
      document.addEventListener("mouseup", stopColumnResize);
    }

    function handleColumnResizeMove(event) {
      if (!columnResizeState.active) return;
      const delta = event.clientX - columnResizeState.startX;
      const newWidth = columnResizeState.startWidth + delta;
      setColumnWidth(columnResizeState.colIndex, newWidth);
    }

    function stopColumnResize() {
      if (!columnResizeState.active) return;
      const colIndex = columnResizeState.colIndex;
      columnResizeState.active = false;
      columnResizeState.startX = 0;
      columnResizeState.startWidth = 0;
      columnResizeState.colIndex = null;

      const header = getHeaderCells()[colIndex];
      if (header) {
        const resizer = header.querySelector(".column-resizer");
        if (resizer) {
          resizer.classList.remove("active");
        }
        header.classList.remove("resizing-hover");
      }

      document.body.classList.remove("resizing-column");
      document.removeEventListener("mousemove", handleColumnResizeMove);
      document.removeEventListener("mouseup", stopColumnResize);
      saveTableState();
    }

    const RESIZE_EDGE_THRESHOLD = 8;

    function isNearRightEdge(event, th) {
      const rect = th.getBoundingClientRect();
      return rect.right - event.clientX <= RESIZE_EDGE_THRESHOLD;
    }

    function clearHeaderDragState() {
      getHeaderCells().forEach((header) => {
        header.classList.remove("drag-over", "dragging");
      });
    }

    function attachHeaderEvents(th) {
      if (th.dataset.eventsAttached === "true") return;

      const initialIndex = getHeaderIndex(th);
      const isLocked = isLockedColumnIndex(initialIndex);
      th.draggable = !isLocked;

      th.addEventListener("mousemove", (e) => {
        if (columnResizeState.active) return;
        const nearEdge = isNearRightEdge(e, th);
        th.classList.toggle("resizing-hover", nearEdge);
      });

      th.addEventListener("mouseleave", () => {
        if (!columnResizeState.active) {
          th.classList.remove("resizing-hover");
        }
      });

      th.addEventListener("mousedown", (e) => {
        if (isNearRightEdge(e, th)) {
          e.preventDefault();
          e.stopPropagation();
          startColumnResize(th, e);
          return;
        }
      });

      th.addEventListener("click", (e) => {
        // Ignore clicks if user is selecting text (simple heuristic)
        if (window.getSelection().toString().length > 0) return;
        if (isDraggingColumn) return;

        const colIndex = getHeaderIndex(th);
        sortTable(colIndex);
      });

      th.addEventListener("dblclick", (e) => {
        e.stopPropagation();
          const label = th.querySelector(".header-label");
          const currentName = (label?.textContent || "").trim();
          const newName = prompt("Rename column:", currentName) || currentName;
          if (label && newName.trim()) {
            label.textContent = newName.trim();
            saveTableState();
          }

          if (th.dataset.type !== COLUMN_TYPES.ICON) {
            const existingFormula = th.dataset.formula || "";
            const formulaInput = prompt(
            "Set formula for this column (use column headers, e.g. =AVERAGE(Rating:Score)). Leave blank to clear.",
            existingFormula
          );

          if (formulaInput !== null) {
            const sanitized = (formulaInput || "").trim();
            if (sanitized) {
              th.dataset.formula = sanitized.startsWith("=")
                ? sanitized
                : "=" + sanitized;
            } else {
              delete th.dataset.formula;
            }

            syncFormulaColumnCells();
            recalculateFormulas();
            saveTableState();
          }
        }
      });

      if (!isLocked) {
        th.addEventListener("dragstart", (e) => {
          dragSourceIndex = getHeaderIndex(th);
          isDraggingColumn = true;
          th.classList.add("dragging");
          e.dataTransfer.setData("text/plain", String(dragSourceIndex));
          e.dataTransfer.effectAllowed = "move";
        });

        th.addEventListener("dragenter", (e) => {
          e.preventDefault();
          th.classList.add("drag-over");
        });

        th.addEventListener("dragover", (e) => {
          e.preventDefault();
          th.classList.add("drag-over");
          e.dataTransfer.dropEffect = "move";
        });

        th.addEventListener("dragleave", () => {
          th.classList.remove("drag-over");
        });

        th.addEventListener("dragend", () => {
          isDraggingColumn = false;
          clearHeaderDragState();
        });

        th.addEventListener("drop", (e) => {
          e.preventDefault();
          const targetIndex = getHeaderIndex(th);
          clearHeaderDragState();

          if (dragSourceIndex === null || dragSourceIndex === targetIndex) {
            isDraggingColumn = false;
            dragSourceIndex = null;
            return;
          }

          reorderColumns(dragSourceIndex, targetIndex);
          isDraggingColumn = false;
          dragSourceIndex = null;
          saveTableState();
        });
      }

      th.dataset.eventsAttached = "true";
    }

    function reorderColumns(fromIndex, toIndex) {
      if (fromIndex === toIndex) return;
      if (isLockedColumnIndex(fromIndex) || isLockedColumnIndex(toIndex)) return;

      const headers = Array.from(headerRow.children);
      const movingHeader = headers[fromIndex];
      if (!movingHeader) return;

      const headersWithoutMoving = headers.filter((_, idx) => idx !== fromIndex);
      const insertBeforeHeader =
        toIndex > fromIndex
          ? headersWithoutMoving[toIndex]
          : headersWithoutMoving[toIndex] || null;

      headerRow.insertBefore(movingHeader, insertBeforeHeader);

      const letterCells = Array.from(letterRow.children);
      const movingLetter = letterCells[fromIndex];
      const lettersWithoutMoving = letterCells.filter((_, idx) => idx !== fromIndex);
      const insertBeforeLetter =
        toIndex > fromIndex
          ? lettersWithoutMoving[toIndex]
          : lettersWithoutMoving[toIndex] || null;

      letterRow.insertBefore(movingLetter, insertBeforeLetter);

      Array.from(tbody.querySelectorAll("tr")).forEach((row) => {
        const cells = Array.from(row.children);
        const movingCell = cells[fromIndex];
        if (!movingCell) return;

        const cellsWithoutMoving = cells.filter((_, idx) => idx !== fromIndex);
        const insertBeforeCell =
          toIndex > fromIndex
            ? cellsWithoutMoving[toIndex]
            : cellsWithoutMoving[toIndex] || null;

        row.insertBefore(movingCell, insertBeforeCell);
      });

      refreshColumnIndices();
      resetSortState();
      syncFormulaColumnCells();
      refreshScrollbars();
      recalculateFormulas();
    }

    function sortTable(colIndex) {
      const rows = Array.from(tbody.querySelectorAll("tr"));
      if (rows.length === 0) return;

      const currentDirection = sortState[colIndex] || "desc";
      const newDirection = currentDirection === "asc" ? "desc" : "asc";
      sortState[colIndex] = newDirection;

      rows.sort((rowA, rowB) => {
        const cellA = rowA.children[colIndex];
        const cellB = rowB.children[colIndex];

        if (!cellA || !cellB) return 0;

        const textA = cellA.textContent.trim();
        const textB = cellB.textContent.trim();

        const numA = parseFloat(textA);
        const numB = parseFloat(textB);

        let cmp;
        if (!isNaN(numA) && !isNaN(numB) && textA !== "" && textB !== "") {
          // Numeric comparison if both cells look like numbers
          cmp = numA - numB;
        } else {
          // String comparison (case-insensitive, numeric-aware)
          cmp = textA.localeCompare(textB, undefined, {
            numeric: true,
            sensitivity: "base",
          });
        }

        return newDirection === "asc" ? cmp : -cmp;
      });

      // Clear tbody and re-append in new order
      tbody.innerHTML = "";
      rows.forEach((row) => tbody.appendChild(row));

      // Update header sort indicators
      updateSortIndicators(colIndex, newDirection);

      saveTableState();
    }

    function updateSortIndicators(activeIndex, direction) {
      const headers = getHeaderCells();
      headers.forEach((th, idx) => {
        const indicator = th.querySelector(".sort-indicator");
        th.classList.remove("sorted-asc", "sorted-desc");

        if (!indicator) return;

        if (idx === activeIndex) {
          if (direction === "asc") {
            indicator.textContent = "‚ñ≤";
            th.classList.add("sorted-asc");
          } else {
            indicator.textContent = "‚ñº";
            th.classList.add("sorted-desc");
          }
        } else {
          indicator.textContent = "‚áÖ";
        }
      });
    }

    function refreshColumnIndices() {
      const headers = getHeaderCells();
      ensureLetterCells(headers.length);
      headers.forEach((th, idx) => {
        th.dataset.colIndex = idx;
        const isLocked = isLockedColumnIndex(idx);
        th.draggable = !isLocked;
        const dragHandle = th.querySelector(".drag-handle");
        if (dragHandle) {
          dragHandle.style.display = isLocked ? "none" : "";
        }
        ensureColumnLetter(th, idx);
      });
      applyStickyColumns();
    }

    function initHeaders() {
      const headers = getHeaderCells();
      ensureLetterCells(headers.length);
      headers.forEach((th, index) => {
        th.dataset.colIndex = index;
        if (!th.dataset.type) {
          th.dataset.type =
            index === 0
              ? COLUMN_TYPES.ICON
              : index === 1
              ? COLUMN_TYPES.NAME
              : COLUMN_TYPES.TEXT;
        }

        ensureColumnLetter(th, index);

        const headerInner = th.querySelector(".header-inner");
        if (
          headerInner &&
          !headerInner.querySelector(".drag-handle") &&
          !isLockedColumnIndex(index)
        ) {
          const dragHandle = document.createElement("span");
          dragHandle.className = "drag-handle";
          dragHandle.textContent = "‚Üï";
          dragHandle.setAttribute("aria-hidden", "true");
          headerInner.insertBefore(dragHandle, headerInner.firstChild);
        }

        ensureColumnResizer(th);

        attachHeaderEvents(th);
      });

      applyStickyColumns();
    }

    function saveTableState() {
      rebuildColumnSuggestionsFromTable();
      const state = collectTableState();
      storage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function buildHeader(
      label,
      index,
      type = COLUMN_TYPES.TEXT,
      formula = "",
      width
    ) {
      const th = document.createElement("th");
      th.dataset.colIndex = index;
      th.dataset.type = type;
      if (formula) {
        th.dataset.formula = formula;
      }
      if (Number.isFinite(width)) {
        th.dataset.width = width;
        th.style.width = `${width}px`;
      }
      if (type === COLUMN_TYPES.ICON) {
        th.classList.add("icon-cell");
      }

      const headerInner = document.createElement("span");
      headerInner.className = "header-inner";

      if (!isLockedColumnIndex(index)) {
        const dragHandle = document.createElement("span");
        dragHandle.className = "drag-handle";
        dragHandle.textContent = "‚Üï";
        dragHandle.setAttribute("aria-hidden", "true");
        headerInner.appendChild(dragHandle);
      }

      const lbl = document.createElement("span");
      lbl.className = "header-label";
      lbl.textContent = label;

      const sortIndicator = document.createElement("span");
      sortIndicator.className = "sort-indicator";
      sortIndicator.textContent = "‚áÖ";

      headerInner.appendChild(lbl);
      headerInner.appendChild(sortIndicator);
      th.appendChild(headerInner);

      ensureColumnResizer(th);

      attachHeaderEvents(th);
      return th;
    }

    function ensureColumnResizer(th) {
      if (th.querySelector(".column-resizer")) return;

      const resizer = document.createElement("span");
      resizer.className = "column-resizer";
      resizer.title = "Drag to resize column";
      resizer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        startColumnResize(th, e);
      });

      th.appendChild(resizer);
    }

    function getColumnDefinitions() {
      return getHeaderCells().map((th, idx) => {
        const label = th.querySelector(".header-label")?.textContent?.trim() ||
          "Column " + (idx + 1);
        const type = th.dataset.type ||
          (idx === 0
            ? COLUMN_TYPES.ICON
            : idx === 1
            ? COLUMN_TYPES.NAME
            : COLUMN_TYPES.TEXT);
        const formula = th.dataset.formula || "";
        const width = getColumnWidth(th);

        return {
          label,
          type,
          formula,
          width: Number.isFinite(width) ? width : undefined,
        };
      });
    }

    function ensureColumnLetter(_th, index) {
      const letterCell = getLetterCells()[index];
      if (!letterCell) return;
      letterCell.dataset.colIndex = index;
      const pill = letterCell.querySelector(".column-letter-pill");
      if (pill) {
        pill.textContent = indexToColumnLabel(index);
      } else {
        letterCell.textContent = indexToColumnLabel(index);
      }
    }

    function getNumericCellValue(row, colIndex) {
      const cell = row.children[colIndex]?.querySelector(".cell, .name-cell");
      if (!cell) return 0;
      const text = cell.textContent.trim();
      const num = parseFloat(text);
      return Number.isFinite(num) ? num : 0;
    }

    function getRangeValues(row, range, labelLookup) {
      const [startLabel, endLabel] = range.split(":").map((part) => part.trim());
      const startIndex = getColumnIndexByLabel(labelLookup, startLabel);
      const endIndex = getColumnIndexByLabel(labelLookup, endLabel);
      if (startIndex === null || endIndex === null) return [];

      const from = Math.min(startIndex, endIndex);
      const to = Math.max(startIndex, endIndex);
      const values = [];
      for (let i = from; i <= to; i++) {
        values.push(getNumericCellValue(row, i));
      }
      return values;
    }

    function evaluateFormula(formula, row) {
      if (!formula) return "";
      const normalized = formula.trim().replace(/^=/, "");
      if (!normalized) return "";

      const labelLookup = getColumnLabelLookup();
      const labelPattern = buildColumnLabelPattern(labelLookup);

      const resolveArguments = (argsStr) =>
        argsStr
          .split(",")
          .flatMap((part) => {
            const trimmed = part.trim();
            if (!trimmed) return [];
            if (trimmed.includes(":"))
              return getRangeValues(row, trimmed, labelLookup);

            const idx = getColumnIndexByLabel(labelLookup, trimmed);
            if (idx !== null) return [getNumericCellValue(row, idx)];

            const direct = parseFloat(trimmed);
            return Number.isFinite(direct) ? [direct] : [];
          })
          .filter((n) => Number.isFinite(n));

      let expression = normalized.replace(
        /\b(SUM|AVERAGE|AVG|MIN|MAX)\s*\(([^()]*)\)/gi,
        (match, fn, args) => {
          const values = resolveArguments(args);
          if (!values.length) return "0";

          switch (fn.toUpperCase()) {
            case "SUM":
              return values.reduce((a, b) => a + b, 0);
            case "AVERAGE":
            case "AVG":
              return values.reduce((a, b) => a + b, 0) / values.length;
            case "MIN":
              return Math.min(...values);
            case "MAX":
              return Math.max(...values);
            default:
              return "0";
          }
        }
      );

      if (labelPattern) {
        expression = expression.replace(labelPattern, (match) => {
          const idx = getColumnIndexByLabel(labelLookup, match);
          if (idx === null) return "0";
          return getNumericCellValue(row, idx);
        });
      }

      if (!/^[0-9+\-*/().\s]+$/.test(expression)) {
        return "ERR";
      }

      try {
        const result = Function("\"use strict\"; return " + expression)();
        if (Number.isFinite(result)) {
          const rounded = Math.round(result * 100) / 100;
          return rounded.toFixed(2);
        }
        return "";
      } catch (err) {
        return "ERR";
      }
    }

    function makeCellFormula(cell) {
      cell.removeAttribute("contenteditable");
      cell.classList.add("formula-cell");
    }

    function ensureEditableCell(cell, columnType) {
      cell.classList.remove("formula-cell");
      cell.setAttribute("contenteditable", "true");
      if (columnType === COLUMN_TYPES.NAME) {
        if (!cell.dataset.nameListenerAttached) {
          cell.addEventListener("input", handleNameInput);
          cell.addEventListener("input", handleCellChange);
          cell.dataset.nameListenerAttached = "true";
        }
      } else {
        if (!cell.dataset.textListenerAttached) {
          cell.addEventListener("input", handleCellChange);
          cell.dataset.textListenerAttached = "true";
        }
      }

      if (!cell.dataset.keyboardListenerAttached) {
        cell.addEventListener("keydown", handleCellKeyDown);
        cell.dataset.keyboardListenerAttached = "true";
      }

      attachSuggestionEvents(cell);
    }

    function syncFormulaColumnCells() {
      const columns = getColumnDefinitions();
      Array.from(tbody.querySelectorAll("tr")).forEach((row) => {
        columns.forEach((col, idx) => {
          if (col.type === COLUMN_TYPES.ICON) return;
          const cell = row.children[idx]?.querySelector(".cell, .name-cell");
          if (!cell) return;

          const isAgeColumn =
            typeof col.label === "string" &&
            col.label.trim().toLowerCase() === AGE_LABEL;

          if (col.formula || isAgeColumn) {
            makeCellFormula(cell);
          } else {
            ensureEditableCell(cell, col.type);
          }
        });
      });
    }

    function recalculateFormulas({ skipAgeUpdate = false } = {}) {
      const columns = getColumnDefinitions();
      const formulaColumns = columns
        .map((col, idx) => ({ idx, formula: col.formula }))
        .filter((entry) => entry.formula && entry.formula.trim());

      if (formulaColumns.length) {
        Array.from(tbody.querySelectorAll("tr")).forEach((row) => {
          formulaColumns.forEach(({ idx, formula }) => {
            const cell = row.children[idx]?.querySelector(".cell, .name-cell");
            if (!cell) return;
            const value = evaluateFormula(formula, row);
            cell.textContent = value;
            applyNumericStyling(cell);
          });
        });
      }

      if (!skipAgeUpdate) {
        updateAgeColumns(columns);
      }

      refreshNumericStyling();
    }

    function findColumnIndexByLabel(columns, targetLabel) {
      return columns.findIndex((col) => {
        const labelText = col.label || "";
        return (
          typeof labelText === "string" &&
          labelText.trim().toLowerCase() === targetLabel
        );
      });
    }

    function getAgeColumnIndices(columns) {
      return columns
        .map((col, idx) => ({ col, idx }))
        .filter(({ col }) => {
          const labelText = col.label || "";
          return (
            typeof labelText === "string" &&
            labelText.trim().toLowerCase() === AGE_LABEL
          );
        })
        .map(({ idx }) => idx);
    }

    const ageRequestTokens = new WeakMap();
    const ageUpdateDebounceTimers = new WeakMap();

    function updateAgeColumns(columns = getColumnDefinitions()) {
      const nameColumnIndex = findColumnIndexByLabel(columns, NAME_LABEL);
      const ageColumnIndices = getAgeColumnIndices(columns);

      if (nameColumnIndex === -1 || ageColumnIndices.length === 0) return;

      const rows = Array.from(tbody.querySelectorAll("tr"));
      rows.forEach((row) => {
        const nameCell = row.children[nameColumnIndex]?.querySelector(
          ".cell, .name-cell"
        );
        const personName = nameCell?.textContent.trim();

        ageColumnIndices.forEach((ageIdx) => {
          const ageCell = row.children[ageIdx]?.querySelector(
            ".cell, .name-cell"
          );
          if (!ageCell) return;

          const requestToken = Symbol("ageRequest");
          ageRequestTokens.set(ageCell, requestToken);

          if (!personName) {
            ageCell.textContent = "";
            applyNumericStyling(ageCell);
            return;
          }

          ageCell.textContent = "‚Ä¶";
          applyNumericStyling(ageCell);

          resolvePersonDates(personName).then((record) => {
            if (ageRequestTokens.get(ageCell) !== requestToken) return;

            if (!record || !record.birth) {
              ageCell.textContent = "";
              applyNumericStyling(ageCell);
              return;
            }

            if (record.death) {
              ageCell.textContent = "dead";
              applyNumericStyling(ageCell);
              return;
            }

            const age = computeAgeFromDates(record.birth);
            ageCell.textContent = Number.isFinite(age) ? age : "";
            applyNumericStyling(ageCell);
          });
        });
      });
    }

    function collectTableState() {
      const headers = getColumnDefinitions();

      const rows = Array.from(tbody.querySelectorAll("tr")).map((tr) => {
        return headers.map((col, idx) => {
          if (col.type === COLUMN_TYPES.ICON) return "";
          const cell = tr.children[idx]?.querySelector(".cell, .name-cell");
          return cell ? cell.textContent : "";
        });
      });

      return { headers, rows };
    }

    function resetSortState() {
      Object.keys(sortState).forEach((key) => delete sortState[key]);
      updateSortIndicators(-1, null);
    }

    function normalizeHeaders(headers) {
      if (!Array.isArray(headers)) return [];

      if (headers.length && typeof headers[0] === "string") {
        return headers.map((label, idx) => ({
          label: label || "Column " + (idx + 1),
          type:
            idx === 0
              ? COLUMN_TYPES.ICON
              : idx === 1
              ? COLUMN_TYPES.NAME
              : COLUMN_TYPES.TEXT,
          formula: "",
          width: undefined,
        }));
      }

      return headers.map((header, idx) => ({
        label: header?.label || header || "Column " + (idx + 1),
        type:
          header?.type ||
          (idx === 0
            ? COLUMN_TYPES.ICON
            : idx === 1
            ? COLUMN_TYPES.NAME
            : COLUMN_TYPES.TEXT),
        formula: header?.formula || "",
        width: Number.isFinite(Number(header?.width))
          ? Number(header.width)
          : undefined,
      }));
    }

    function applyState(state) {
      if (!state || !Array.isArray(state.headers) || !Array.isArray(state.rows)) {
        return false;
      }

      const normalizedHeaders = normalizeHeaders(state.headers);
      headerRow.innerHTML = "";
      letterRow.innerHTML = "";
      normalizedHeaders.forEach((header, idx) => {
        const th = buildHeader(
          header.label || "Column " + (idx + 1),
          idx,
          header.type,
          header.formula,
          header.width
        );
        headerRow.appendChild(th);
        ensureLetterCells(idx + 1);
      });

      tbody.innerHTML = "";
      state.rows.forEach((rowData) => {
        const tr = document.createElement("tr");
        normalizedHeaders.forEach((col, idx) => {
          const td = createCell(col.type, { formula: col.formula });
          const val = rowData[idx] || "";
          if (col.type !== COLUMN_TYPES.ICON) {
            const cellEl = td.querySelector(".name-cell, .cell");
            if (cellEl) {
              cellEl.textContent = val;
            }
          }
          tr.appendChild(td);
        });

        // After the row is assembled and attached, wire the image icon to the
        // saved name so image links work immediately on page load.
        const nameCell = tr.querySelector(".name-cell");
        if (nameCell) {
          handleNameInput({ target: nameCell });
        }

        tbody.appendChild(tr);
      });

      applySavedColumnWidths();
      syncColumnLetterWidths();
      initHeaders();
      refreshColumnIndices();
      resetSortState();
      syncFormulaColumnCells();
      recalculateFormulas();
      rebuildColumnSuggestionsFromTable();
      refreshScrollbars();
      return true;
    }

    function buildDefaultState() {
      const rows = Array.from({ length: DEFAULT_ROW_COUNT }, () =>
        DEFAULT_HEADERS.map(() => "")
      );

      return { headers: DEFAULT_HEADERS, rows };
    }

    function loadTableState() {
      const saved = storage.getItem(STORAGE_KEY);
      if (!saved) return false;

      try {
        const state = JSON.parse(saved);
        if (!applyState(state)) {
          return false;
        }
        return true;
      } catch (err) {
        console.warn("Failed to load saved table state", err);
        return false;
      }
    }

    function bootstrap() {
      const restored = loadTableState();
      if (!restored) {
        applyState(buildDefaultState());
        saveTableState();
      }
    }

    // Capture any last-minute edits when the tab is about to close or hide.
    window.addEventListener("beforeunload", saveTableState);
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        saveTableState();
      }
    });

    function exportData() {
      const state = collectTableState();
      const json = JSON.stringify(state, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      const today = new Date().toISOString().split("T")[0];
      link.href = url;
      link.download = `table-data-${today}.json`;
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    }

    function handleImportFile(event) {
      const file = event.target.files?.[0];
      if (!file) return;

      const fileName = file.name.toLowerCase();

      if (fileName.endsWith(".json")) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const parsed = JSON.parse(e.target?.result);
            const applied = applyState(parsed);
            if (!applied) {
              alert("Import failed: file is missing headers or rows.");
              return;
            }
            saveTableState();
          } catch (err) {
            console.error("Import failed", err);
            alert("Import failed: invalid JSON file.");
          } finally {
            importFileInput.value = "";
          }
        };
        reader.readAsText(file);
      } else if (
        fileName.endsWith(".xlsx") ||
        fileName.endsWith(".xls") ||
        fileName.endsWith(".csv")
      ) {
        parseExcelFile(file);
      } else {
        alert("Unsupported file type. Please upload a JSON or Excel file.");
        importFileInput.value = "";
      }
    }

    function buildStateFromMatrix(matrix) {
      if (!Array.isArray(matrix) || matrix.length === 0) return null;

      const [headerRow, ...rows] = matrix;
      if (!headerRow || headerRow.length === 0) return null;

      const dataHeaders = headerRow.map((label, idx) => ({
        label: label || `Column ${idx + 1}`,
        type: idx === 0 ? COLUMN_TYPES.NAME : COLUMN_TYPES.TEXT,
        formula: "",
      }));

      const headers = [
        { label: "Images", type: COLUMN_TYPES.ICON },
        ...dataHeaders,
      ];

      const normalizedRows = rows.map((row) => {
        const cells = new Array(headers.length).fill("");
        row.forEach((value, idx) => {
          cells[idx + 1] = value ?? "";
        });
        return cells;
      });

      return { headers, rows: normalizedRows };
    }

    function parseExcelFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target?.result);
          const workbook = XLSX.read(data, { type: "array" });
          const firstSheet = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheet];

          if (!worksheet) {
            alert("Import failed: the Excel file has no sheets.");
            return;
          }

          const matrix = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
          const state = buildStateFromMatrix(matrix);

          if (!state || !applyState(state)) {
            alert("Import failed: Excel file is missing header or row data.");
            return;
          }

          saveTableState();
        } catch (err) {
          console.error("Import failed", err);
          alert("Import failed: unable to read the Excel file.");
        } finally {
          importFileInput.value = "";
        }
      };

      reader.readAsArrayBuffer(file);
    }

    document.addEventListener("click", (event) => {
      if (suggestionDropdown.classList.contains("hidden")) return;
      if (suggestionDropdown.contains(event.target)) return;
      if (activeSuggestionCell && activeSuggestionCell.contains(event.target)) {
        return;
      }

      hideSuggestionDropdown();
    });

    function clearData() {
      const confirmed = confirm(
        "This will remove all rows and reset the table to its default state. Continue?"
      );

      if (!confirmed) return;

      storage.removeItem(STORAGE_KEY);
      applyState(buildDefaultState());
      saveTableState();
    }

    bootstrap();

    // Button wiring
    addRowBtn.addEventListener("click", addRow);
    addColBtn.addEventListener("click", addColumn);
    deleteRowBtn.addEventListener("click", deleteRow);
    deleteColBtn.addEventListener("click", deleteColumn);
    exportBtn.addEventListener("click", exportData);
    importBtn.addEventListener("click", () => importFileInput.click());
    clearBtn.addEventListener("click", clearData);
    importFileInput.addEventListener("change", handleImportFile);
  </script>
</body>
</html>
